# Automated-Repo-Setup

## Hidden testing

This project features hidden testing. In this context hidden testing means that tests can be seperated from the code repository. Students can see the source code of tests which are located within the code repository. They use this repository to solve their exercises. Tests which source code should be hidden from students are located in the test repository. 

Keep in mind that error stack traces and error messages of tests within the test repository are not hidden on the *test overview page*. If you want to hide these info as well read the chapter *test overview page* as well.

### Code and test repository

Automated testing occures every time when new code is submitted to the code repository. But the test repository needs to know when to execute tests as well because this wont happen automatically since students dont commit code to the test repositories. This is solved by the file ".gitlab-ci.yml" which tells the code repository to notify the test repository on every build. The two repositories are linked automatically using *pipeline variables* by this tool. 

**Attention**: This means that an URL to a project must not change because then the test repository does not know the updated URL to the code repository. Even if you rename the variables manually the pages functionality will not function because of a [bug](https://gitlab.com/gitlab-org/gitlab-foss/-/issues/61011).

If you dont want any hidden tests and no resulting test repository you can use the pipeline file "gitlab-ci-no-test-repo.yml". Then the test overview page will be generated from the code repository

Although code and test files are separeted into two repositories the exercise only consists of one repository called the origin. It would be really troublesome if you would have to update two repositories all the time while creating a new exercise. In order to prevent this the corresponding code and test repositories are generated by the tool automatically. If you want some files to only be copied to a specific repository you can express this behaviour in the filename.

If the filename contains the string *_coderepo* the file will only be copied to the code repository.
If the filename contains the string *_testrepo* the file will only be copied to the test repository.
If the filename contains the string *_norepo* the file will not be copied to the repositories. This can be used to store config files from this tool directly in the origin repository.
If the filename contains none of those the file will be copied to both repositories.

The following URL leads to an example project which can be used as guidance:

Example Origin Repo: https://git.st.archi-lab.io/staff/st2/ms-spring/st2-praktikum-origin-repo

### Test overview page

To give an overview on passed and failed tests of an repository a test overview page will be generated using the project *test-report-page-generator*. The generator is called within the ".gitlab-ci.yml" file in the *deploy* stage.

Passed tests will be shown in green color and failed tests in red color. It is possible to click on an red colored test to get the error stack trace and error message. This does not work if a test has the key word *hidden* in its name which marks the test as an hidden test. 

The overview page's URL is depending on the URL of the repository which contains the test. The following example shows how a pair of URLs could be:

Repository URL: https://git.coco.study/staff/infrastructure/hiddentesting/example-repo_tests_group_1

Overview Page URL: https://staff.pages.coco.study/infrastructure/hiddentesting/example-repo_tests_group_1/

### Link overview page

To give the supervisor of the course an overview of all generated repositories, a report table can be generated automatically. Each time the tool is run a new table will be generated and pushed to the configured repository which is defined in the file "repositoryConfig.json". The table in form of a markdown file will consist of three columns. The group names of the members from the repository, a link to the code repository and a link to the test overview page.

## Tool

### Setup & Run

1. Install NodeJs (version >= 12.0.0) which is required to run this tool. NodeJs can be acquired on the website [nodejs.org](https://nodejs.org/en/download/).

2. To use this tool you have to clone this repository to your local drive.

3. This tool uses several libraries in order to use the Gitlab API etc. Install these libraries by running the command ```npm install``` in the root folder of this project.

4.  a)  For local use only

    1. Copy the origin repository into the folder *test_folder/input*. If this folder does not exist, create the folder *test_folder* inside the root of this tool and then create the folder *input* in the newly created folder *test_folder*
    2. The generated repositories will be located under *test_folder/output* after running the tool

    b)  For use with Gitlab:

    1. Navigate to https://git.st.archi-lab.io/profile/personal_access_tokens and generate an Access Token / API-Token in order to get access to the gitlab api
    2. Copy the Access Token
    3. Rename the file .env.example to .env
    4. Open .env and replace *YOUR_API_TOKEN* with the token you copied.
    5. Configure the source repository and target group in the config

5. Before you can configure or run this tool you have to copy all the example config files inside the "config/examples" folder to the "config" folder in order to create your own config files. If you want to change the standard behaviour you can configure this tool by editing the configs. See the chapter *Configuration* for a detailed explanation.

6. To run the application navigate into the root folder of this tool and run ```npm start```. The repositories will now be generated.

### Configuration

#### Repository config

Configure the options for repository creation in the file "repositoryConfig.json":
```
{
    "general": {
        # Decide wheather you just want to test locally
        "localMode": true,

        # Decide wheather test repositories should be generated as well
        "createTestRepository": true,

        # Decide wheather the repositories should be randomized using the "variationsConfig.json"
        "variateRepositories": true,

        # The Name of the repositories. Multiple repositories will be named <repositoryName>_group_<uuid>, <repositoryName>_tests_group_<uuid> ...
        "repositoryName": "st2-praktikum",

        # The number of repositories which will be created
        "repositoryCount": 0,

        # The user names of the members which will get Maintainer rights
        "repositoryMembers": [
            ["st2-praktikum"]
        ]
    },
    "local": {
        # The file path to an origin repository which should be used for local testing
        "originRepositoryFilePath": ""
    },
    "remote": {
        # Id of the repository you want to clone
        "originRepositoryId": 741,

        # The ids of the target groups where all repositories will be located
        "codeRepositoryTargetGroupId": 140,
        "testRepositoryTargetGroupId": 141
    },
    "overview": {
        "generateOverview": true,
        "overviewRepositoryId": 745,
        "overviewFileName": "st2-praktikum"
    },
    "individualRepositoryPersist": {
        "useSavedIndividualRepositories": false,
        "savedIndividualRepositoriesFileName": "individual_repositories_16-07-2020 14-12-50.json"
    }
}
```

If *localMode* is set to true the application will only generate possible variable variations and randomize files based on a folder which contains the origin repository. This folder should be located in the folder "test_folder/input". If the folder "test_folder/input" does not exist create it within the root folder of this tool or run the tool once in test mode which will generate this folder automatically. This can be used to get an idea which repositories will result based on the configs. The following example shows the location of the origin folder:

```
root_of_tool
    - build
    - node_modules
    - src
    - .gitignore
    - .Readme
    - test_folder
        - input
            - origin-folder
                - src
                - .gitignore
                - .Readme      
```

If you dont want to copy the origin repository each time you want to test a new version specify the file path to the origin repository in the config under *local.originRepositoryFilePath*.

#### Origin Repository config

Configure the options for solution deletion and warnings in the file "originRepositoryConfig.json":
```
{
    "solutionDeletion": {
        "deleteSolution": true,
        "deleteFileKey": "//deleteFile",
        "deleteParagraphKey": "//delete",
        "replaceKey": "//replace",
        "replaceValue": "throw new UnsupportedOperationException();"
    },
    "warnings": {
        # These warnings are related to variable values from the solution which were not replaced with variables
        "variableValueWarnings": {
            "activate": true,
            # The mechanism will only print warnings for files which have one of the following types
            "typeWhiteList": [
                "json",
                "java",
                "md"
            ],
            # Possible wrong variable values which are included in one of the following items will be ignored
            "ignoreList": [
                "name",
                "type"
            ]
        }
    }
}
```

##### Delete solution config

If you want solutions which are contained in your origin project to be removed while creating the code and test repositories enable solution deletion in the repository config. The repository config specifies also the keywords which are used to either

- delete a file
- delete a paragraph
- replace a paragraph

This can be shown best with an example:

```java
// TODO calculate the sum of number 1 and number 2 and return the result
public static int sumInt(int number1, int number2) {
    //replace
    return number1 + number2;
    //replace
}

// TODO calculate the product of number 1 and number 2 and return the result
public static int multiplyInt(int number1, int number2) {
    //delete
    return number1 * number2;
    //delete
}
```

will be changed to:


```java
// TODO calculate the sum of number 1 and number 2 and return the result
public static int sumInt(int number1, int number2) {
    throw new UnsupportedOperationException();
}

// TODO calculate the product of number 1 and number 2 and return the result
public static int multiplyInt(int number1, int number2) {
    
}
```

##### Link overview page config

If you have the generation of the overview table enabled in the repository config the destination and the name of the overview table can be defined in the file "repositoryConfig.json" as well.

##### Individual repository persist config

If you run the tool the default behaviour is that it will generate individual variables for each repository which in specified in the config. If you want to reuse already generated variables you can set "useSavedIndividualRepositories" to "true" and define a file name under "savedIndividualRepositoriesFileName". The file name is relative to the folder "individual_repositories_folder" and is defined in the "repositoryConfig.json".

#### Randomization configs

If you want your project to be randomized slightly use the file "variationsConfig.json" to create variables. Variables can be referenced by their name encapsulated in dollar signs. e.g.: $THIS_IS_A_VARIABLE$. There are three types of variables:

##### Object Variables

 *Object Variables* are used to randomize Entities and Value Objects. Such variables are created by defining one or multiple ids and an array of possible object variations. Object variations can contain attributes which will later be transformed into a variable. An example attribute could be *class_name* which contains the class name of an entity. The following json shows a possible declaration of two object variations:

 ```json
{
    "ids": "vehicle",
    "objectVariations": [
        {
            "id": "car",
            "class_name": "Car",
            "repo_class_name": "CarRepository",
            "set_to_one": "setCar",
            "set_to_many": "setCars"
        },  
        {
            "id": "truck",
            "class_name": "Truck",
            "repo_class_name": "TruckRepository",
            "set_to_one": "setTruck",
            "set_to_many": "setTrucks"
        },  
        {
            "id": "train",
            "class_name": "Train",
            "repo_class_name": "TrainRepository",
            "set_to_one": "setTrain",
            "set_to_many": "setTrains"
        }
    ],
    "variableExtensions": [ "GETTER" ]
},
{
    "ids": ["wheel_1", "wheel_2"],
    "objectVariations": [
        {
            "id": "front_wheel",
            "class_name": "FrontWheel",
            "repo_class_name": "FrontWheelRepository",
            "set_to_one": "setFrontWheel",
            "set_to_many": "setFrontWheels"
        },
        {
            "id": "back_wheel",
            "class_name": "BackWheel",
            "repo_class_name": "BackWheelRepository",
            "set_to_one": "setBackWheel",
            "set_to_many": "setBackWheels"
        }
    ],
    "variableExtensions": [ "GETTER" ]
}
 ```

 The defined object variations are now randomly assigned to the variables *vehicle*, *wheel_1* and *wheel_2*. The following dictionary shows variables which result from above declaration:

 ```
VEHICLE_CLASS_NAME: 'Truck',
VEHICLE_REPO_CLASS_NAME: 'TruckRepository',
VEHICLE_GET_TO_ONE: 'getTruck',
VEHICLE_GET_TO_MANY: 'getTrucks',
VEHICLE_SET_TO_ONE: 'setTruck',
VEHICLE_SET_TO_MANY: 'setTrucks',
WHEEL_1_CLASS_NAME: 'Backwheel',
WHEEL_1_REPO_CLASS_NAME: 'BackwheelRepository',
WHEEL_1_GET_TO_ONE: 'getBackWheel',
WHEEL_1_GET_TO_MANY: 'getBackWheels',
WHEEL_1_SET_TO_ONE: 'setBackWheel',
WHEEL_1_SET_TO_MANY: 'setBackWheels',
WHEEL_2_CLASS_NAME: 'FrontWheel',
WHEEL_2_REPO_CLASS_NAME: 'FrontWheelRepository',
WHEEL_2_GET_TO_ONE: 'getFrontWheel',
WHEEL_2_GET_TO_MANY: 'getFrontWheels',
WHEEL_2_SET_TO_ONE: 'setFrontWheel',
WHEEL_2_SET_TO_MANY: 'setFrontWheels'
 ```

 In the example above you can see that some variables could be derived from already existing variables. The *setter* variables are a perfect example for this. Such variables can also be defined through variable extensions. This is done for the *getter* variables in the example. Two steps are required to define such derived variables:

 1. Define a rule for a variable extension in the config "variableExtensionsConfig.json":

 ```json
{
    "id": "getter",
    "variableExtensions": 
    {
        "get_to_one": 
        {
            "preValue": "get",
            "value": "CLASS_NAME",
            "postValue": "",
            "modifier": "NONE"
        }, 
        "get_to_many": 
        {
            "preValue": "get",
            "value": "PLURAL",
            "postValue": "",
            "modifier": "NONE"
        }
    }   
}
 ```
 
 The *value* attribute references an already existing variable which is modified through the given *modifier*. Valid modifiers can for example convert the given variable to an all lower case variant.

 The resulting value is then concatenated with the *preValue* and *postValue* like so: preValue + modifier(value) + postValue. 

 2. Define a certain variable extension for an object by adding the id of the variable extension to the list of variable extensions of an object (see example above).
 
 ##### Relation Variables

 *Relation Variables* are used to randomize relations between entities. They are defined by declaring an array of *relationships* and an array of *relationObjects*. Both arrays must be of equal length because each set of relationObjects will be assigned to an relationShip.

 In order to define a relationShip you have to provide an id and a reference to an relationShip type. These types are defined in the file "relationsConfig.json" and can contain any kind of attributes:

 ```json
{
    "id": "one_to_one",
    "umlet": "lt=-\nm1=1\nm2=1",
    "short": "1 - 1",
    "description": "one to one"
}
 ```

 In order to define a set of relationObjects you have to provide an id and two object references. The following json shows an example definition for relations (Note that all uppercase string are references):

 ```json
{
    "relationShips": [
        {
            "id": "rel_1",
            "relationType": "ONE_TO_ONE"
        }, {
            "id": "rel_2",
            "relationType": "ONE_TO_MANY"
        }
    ],
    "relationObjects": [
        {
            "id": "rel_vehicle_wheel_1",
            "obj_1": "VEHICLE",
            "obj_2": "WHEEL_1"
        }, {
            "id": "rel_vehicle_wheel_2",
            "obj_1": "VEHICLE",
            "obj_2": "WHEEL_2"
        }
    ]
}
 ```

For each relationships two kind of variables will be generated. 

- One kind of variable will clarify which objects belong to a certain relationship. These variables will start with for example *rel_1* as defined in the section *relationShips*.

- Another kind of variable will clarify which relationship belongs to a set of objects. These variables will start with for example *rel_vehicle_wheel_1* as defined in the section *relationObjects*.

For each of these two kinds a set of variables will be gernated. One the one side these contain attributes of the relation types defined in "relationsConfig.json". On the other side these contain attributes of the objects defined in the file "variationsConfig.json".

The following json shows a set of variables which will be generated for a single relationship:

```
REL_1_UMLET: 'lt=-\nm1=1\nm2=1',
REL_1_SHORT: '1 - 1',
REL_1_DESCRIPTION: 'one to one',
REL_1_OBJ_1_CLASS_NAME: 'Truck',
REL_1_OBJ_1_REPO_CLASS_NAME: 'TruckRepository',
REL_1_OBJ_1_GET_TO_ONE: 'getTruck',
REL_1_OBJ_1_GET_TO_MANY: 'getTrucks',
REL_1_OBJ_1_SET_TO_ONE: 'setTruck',
REL_1_OBJ_1_SET_TO_MANY: 'setTrucks',
REL_1_OBJ_2_CLASS_NAME: 'Backwheel',
REL_1_OBJ_2_REPO_CLASS_NAME: 'BackwheelRepository',
REL_1_OBJ_2_GET_TO_ONE: 'getBackWheel',
REL_1_OBJ_2_GET_TO_MANY: 'getBackWheels',
REL_1_OBJ_2_SET_TO_ONE: 'setBackWheel',
REL_1_OBJ_2_SET_TO_MANY: 'setBackWheels',

REL_VEHICLE_WHEEL_1_UMLET: 'lt=-\nm1=1\nm2=1',
REL_VEHICLE_WHEEL_1_SHORT: '1 - 1',
REL_VEHICLE_WHEEL_1_DESCRIPTION: 'one to one',
REL_VEHICLE_WHEEL_1_OBJ_1_CLASS_NAME: 'Truck',
REL_VEHICLE_WHEEL_1_OBJ_1_REPO_CLASS_NAME: 'TruckRepository',
REL_VEHICLE_WHEEL_1_OBJ_1_GET_TO_ONE: 'getTruck',
REL_VEHICLE_WHEEL_1_OBJ_1_GET_TO_MANY: 'getTrucks',
REL_VEHICLE_WHEEL_1_OBJ_1_SET_TO_ONE: 'setTruck',
REL_VEHICLE_WHEEL_1_OBJ_1_SET_TO_MANY: 'setTrucks',
REL_VEHICLE_WHEEL_1_OBJ_2_CLASS_NAME: 'Backwheel',
REL_VEHICLE_WHEEL_1_OBJ_2_REPO_CLASS_NAME: 'BackwheelRepository',
REL_VEHICLE_WHEEL_1_OBJ_2_GET_TO_ONE: 'getBackWheel',
REL_VEHICLE_WHEEL_1_OBJ_2_GET_TO_MANY: 'getBackWheels',
REL_VEHICLE_WHEEL_1_OBJ_2_SET_TO_ONE: 'setBackWheel',
REL_VEHICLE_WHEEL_1_OBJ_2_SET_TO_MANY: 'setBackWheels',
```

##### Logic variables

*Logic Variables* are used to randomize logic elements of an exercise. The idea behind this concept is that you can define multiple groups of business logic, but only one group of business logic is assigned to each individual exercise. Logic variables can also be used to define text which decribes a certain business logic. Here is an example for the definition of logic variables:

```json
{
    "id": "logic_1",
    "logicVariations": [
        {
            "id": "vehicle_crash",
            "description": "Keep in mind that this text is just an example. \nThis is a new line" 
        },
        {
            "id": "vehicle_shop",
            "description": "The Vehicle Shop exercise was selected" 
        }
    ]
}
```

Above example will generate only one variable which is called *LOGIC_1_DESCRIPTION*. The interesting part of the logic variations are the *ids*. If you add an *underscore* followed by such an *id* to the end of a file this file is only inserted into an individual repository if the said id was selected during the randomization. 

e.g.: The file VehicleCrashTest_vehicle_crash.java is only inserted if the logic *vehicle_crash* was selected. The file VehicleShopTest_vehicle_shop.java is only inserted if the logic *vehicle_shop* was selected.

This can be used to dynamically insert certain test classes which test a specific business logic. If a certain test class was not inserted to an individual repository the one who solves this exercise does not have to implement the corresponding business logic.

## Example procedure when creating exercises

1. Create a solution project which contains all neccessary tests and a possible solution for these tests. This project is used to test wheather the written tests can be successful if the written code is correct.
2. Create a new origin project and copy the code and test files which should remain in the exercise from the previous project and replace entity names etc. with the placeholder variables which you define in the config file "variationsConfig.json". 
3. Dont forget to add the corresponding pipeline config files called *gitlab-ci.yml* to the repository. 
The file for the code repository should be called *gitlab-ci_coderepo.yml* and
the file for the test repository should be called *gitlab-ci_testrepo.yml*.
In addition add the script *setup_test_environment_testrepo.sh* to the test repository.
The postfixes *_coderepo* and *_testrepo* are used to define seperate ci files for the code and test repos. They will be renamed to *gitlab-ci.yml*.
3. Now use the folder "test_folder" to replace variables with their corresponding values to test if everything works as planned. This is a local approach that will not generate repositories inside gitlab.
4. At last you can do a test run by generating repositories from the exercise project with the tool and solving the exercise. Remember that you can reuse the code from the solution project to solve a specific individual exercise. If your solution is correct and all tests passed you created a valid exercise!





